# 06: Create-React-App, JSX, Components and Lifecycle

## Create React App

**create-react-app** is a command line tool that helps developers quickly set up a new **React** project with a basic file structure and a development environment to use modern best practices.

**Activity:** Create a new **React** application using **create-react-app** and the internet.

When you run the `npx create-react-app <name of app>` command, it will generate a new directory that includes everything you need to start building a **React** application. This directory includes the following:

- `node_modules/`: This directory contains all of the project's required packages.
- `public/`: This directory contains files that will be publicly accessible such as the `index.html` file, static assets, and the `manifest.json` file.
- `src/`: This directory contains the project's source code files, including subdirectories for components, styles and any other code specific to the application.
- `src/index.js`: This file is the entry point of the app, and it is where the **React** application is rendered.
- `.gitignore`: This file contains a list of files and directories that should be ignored by **Git** when committing changes.
- `package.json`: This file contains metadata about the project, including its dependencies, scripts, and information about its authors and license.
- `README.md`: This file contains documentation about the project.
- `yarn.lock` or `package-lock.json`: This file is automatically generated for any operations where npm modifies either the `node_modules` tree or `package.json`. It describes the exact tree generated, such that subsequent installs can generate identical trees, regardless of intermediate dependency updates.

**Activity:** Find **two** alternatives to **create-react-app**.

## JSX

**JSX** is a syntax extension for **JavaScript** that allows you to write **HTML-like** elements and components in **JavaScript**. It was developed by **Facebook** and is commonly used in **React** and other **JavaScript** libraries and frameworks.

For example, you can use **JSX** to create a simple component like this:

```jsx
const MyFirstComponent = () => {
  return <p>Hello, World!</p>;
};

export default MyFirstComponent;
```

Here, the **JSX** syntax `<p>Hello, World!</p>` creates a `p` element with the text "Hello, World!" inside of it.

**JSX** is not directly readable by the browser, it needs to be transpiled by a tool like **Babel**, which converts the **JSX** code into regular **JavaScript** that the browser can understand.

**JSX** is an important part of **React's** component-based architecture (more about this soon), as it allows you to describe the structure and content of a component in a declarative and intuitive way. It also makes it easy to pass data and interact with a component's state.

**Activity:** In the `src` directory, create a new directory call `components`. In the `components` directory, create a new `MyFirstComponent.js`. In the `MyFirstComponent.js` file, add the code above.

## Components

In **React**, a component is a piece of code that represents a part of a user interface. Components are reusable, meaning they can be used multiple times throughout an application.

In **React**, there are two types of components - function and class. In this course, disregard any examples of class components. A function component (like the `MyComponent` above) is a **JavaScript** function that returns a component's structure and content.

### Lifecycle

In **React**, every component has a **lifecycle** - **mounting**, **updating** and **unmounting**. These **lifecycle** methods are useful because we want to execute a piece of code a specific time. **React** provides a **hook** to create these methods called `useEffect`.

The `useEffect` **hook** is used to perform side-effects, such as fetching data, after the component has rendered.

Here is an example:

```jsx
import { useState, useEffect } from "react";

const MyLifecycle = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      });
  }, []);

  return (
    <>
      {loading ? (
        <p>Loading...</p>
      ) : (
        <ul>
          {data.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      )}
    </>
  );
};

export default MyLifecycle;
```

The `useEffect` arguments are a callback function and dependency array. If the dependency array is empty, then that callback function will only be called once. If the dependency array is not empty, the callback function will be called when a value in the dependency array changes.

Here is an example:

```jsx
import { useState, useEffect } from "react";

const MyCounterTwo = () => {
  const [increment, setIncrement] = useState(0);
  const [decrement, setDecrement] = useState(0);

  useEffect(() => {
    console.log("componentDidMount");
  }, []);

  useEffect(() => {
    console.log("componentDidUpdate - increment");
  }, [increment]);

  useEffect(() => {
    console.log("componentDidUpdate - decrement");
  }, [decrement]);

  return (
    <>
      <button onClick={() => setIncrement(increment + 1)}>Increment</button>
      <h1>{increment}</h1>
      <button onClick={() => setDecrement(decrement - 1)}>Decrement</button>
      <h1>{decrement}</h1>
    </>
  );
};

export default MyCounterTwo;
```

What about **unmounting**? Here is an example:

```jsx
import { useState, useEffect } from "react";

const Child = () => {
  useEffect(() => {
    console.log("componentWillUnmount");
  }, []);

  return (
    <>
      <h1>Child Component</h1>
    </>
  );
};

const Parent = () => {
  const [isToggled, setIsToggled] = useState(false);

  return (
    <>
      <button onClick={() => setIsToggled(!isToggled)}>Toggle Child</button>
      {isToggled ? <Child /> : null}
    </>
  );
};

export default Parent;
```

# Formative Assessment

Use the following repository - <https://classroom.github.com/a/M8iqQ-92>. Before you start, create a new branch called **react-1-formative-assessments**. 

If you get stuck on any of the following tasks, feel free to use **ChatGPT** permitting, you are aware of the following:

- If you provide **ChatGPT** with a prompt that is not refined enough, it may generate a not-so-useful response
- Do not trust **ChatGPT's** responses blindly. You must still use your judgement and may need to do additional research to determine if the response is correct
- Acknowledge that you are using **ChatGPT**. In the **README.md** file, please include what prompt(s) you provided to **ChatGPT** and how you used the response(s) to help you with your work

## Task 1


## Task 2


## Task 3


# Formative Assessment Submission

Create a new pull request and assign **grayson-orr** to review your submission. Please don't merge your own pull request.
